"""
Curriculum API Routes

Endpoints for:
- Generating personalized curriculum from syllabus
- Managing student curriculum progress
- Getting daily goals and milestones
"""
from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
import logging
from datetime import datetime

router = APIRouter(prefix="/api/curriculum", tags=["Curriculum"])

logger = logging.getLogger(__name__)


# ============================================================================
# Request/Response Models
# ============================================================================

class GenerateCurriculumRequest(BaseModel):
    """Request to generate curriculum from syllabus"""
    syllabus_id: str = Field(..., description="ID of processed syllabus")
    user_id: str = Field(..., description="Student ID")
    classroom_id: str = Field(default="", description="Classroom ID")
    subject_name: str = Field(..., description="Subject name")
    
    # Optional: pre-loaded topics (skip fetching from DB)
    topics: Optional[List[Dict]] = Field(
        default=None, 
        description="Pre-loaded topics (optional, fetched from syllabus if not provided)"
    )
    
    # Schedule configuration
    hours_per_day: float = Field(default=2.0, ge=0.5, le=8.0, description="Study hours per day")
    deadline_days: int = Field(default=14, ge=1, le=365, description="Days until deadline")
    start_date: Optional[str] = Field(default=None, description="Start date YYYY-MM-DD")


class TopicProgress(BaseModel):
    """Progress on a single topic"""
    topic_id: str
    topic_name: str
    status: str  # "not_started", "in_progress", "completed"
    mastery: float = 0.0
    time_spent_min: int = 0


class DailyGoalResponse(BaseModel):
    """Daily learning goal"""
    day: int
    date: str
    topics: List[str]
    activities: List[Dict]
    total_hours: float
    milestone: Optional[str] = None
    completed: bool = False


class CurriculumResponse(BaseModel):
    """Full curriculum response"""
    id: str
    user_id: str
    syllabus_id: str
    subject_name: str
    created_at: str
    
    # Topics
    topics: List[Dict]
    topic_order: List[str]
    total_topics: int
    
    # Schedule
    start_date: str
    end_date: str
    total_days: int
    hours_per_day: float
    daily_goals: List[DailyGoalResponse]
    milestones: List[Dict]
    
    # Progress
    current_topic_index: int = 0
    completed_topics: List[str] = []
    progress_percent: float = 0.0


class UpdateProgressRequest(BaseModel):
    """Update curriculum progress"""
    curriculum_id: str
    topic_id: str
    status: str  # "in_progress", "completed"
    mastery: Optional[float] = None
    time_spent_min: Optional[int] = None


# ============================================================================
# Endpoints
# ============================================================================

@router.post("/generate", response_model=Dict[str, Any])
async def generate_curriculum(request: GenerateCurriculumRequest):
    """
    Generate a personalized curriculum from syllabus.
    
    This endpoint:
    1. Takes a processed syllabus ID
    2. Analyzes topic dependencies using AI
    3. Creates an optimal learning path
    4. Generates a daily schedule with milestones
    
    The curriculum can be generated by:
    - **Students**: Upload their syllabus to get a study plan
    - **Teachers**: Create curriculum for a classroom
    
    Example:
    ```json
    {
        "syllabus_id": "abc123",
        "user_id": "student456",
        "subject_name": "Mathematics",
        "hours_per_day": 2,
        "deadline_days": 30
    }
    ```
    """
    try:
        from app.agents import get_curriculum_agent
        
        agent = get_curriculum_agent()
        
        result = await agent.generate({
            "syllabus_id": request.syllabus_id,
            "user_id": request.user_id,
            "classroom_id": request.classroom_id,
            "subject_name": request.subject_name,
            "raw_topics": request.topics or [],
            "hours_per_day": request.hours_per_day,
            "deadline_days": request.deadline_days,
            "start_date": request.start_date or datetime.now().strftime("%Y-%m-%d")
        })
        
        if not result.get("success"):
            raise HTTPException(
                status_code=400,
                detail=result.get("error", "Failed to generate curriculum")
            )
        
        # Calculate progress percent
        curriculum = result.get("curriculum", {})
        total_topics = len(curriculum.get("topics", []))
        completed = len(curriculum.get("completed_topics", []))
        progress = (completed / total_topics * 100) if total_topics > 0 else 0
        
        # Store curriculum for persistence (Phase 4)
        try:
            from app.services.curriculum_storage import get_curriculum_storage
            storage = get_curriculum_storage()
            storage.save_curriculum(curriculum)
            logger.info(f"[CURRICULUM-API] Stored curriculum {curriculum.get('id', 'unknown')[:8]}...")
        except Exception as storage_err:
            logger.warning(f"[CURRICULUM-API] Storage warning: {storage_err}")
        
        return {
            "success": True,
            "curriculum": {
                **curriculum,
                "total_topics": total_topics,
                "progress_percent": round(progress, 1)
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Generate error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/user/{user_id}")
async def get_user_curricula(
    user_id: str,
    syllabus_id: Optional[str] = Query(None, description="Filter by syllabus")
):
    """
    Get all curricula for a user.
    
    Fetches from Redis storage with in-memory fallback.
    """
    try:
        from app.services.curriculum_storage import get_curriculum_storage
        
        storage = get_curriculum_storage()
        curricula = storage.get_user_curricula(user_id)
        
        # Filter by syllabus if specified
        if syllabus_id:
            curricula = [c for c in curricula if c.get("syllabus_id") == syllabus_id]
        
        # Add summary info
        summaries = []
        for c in curricula:
            summaries.append({
                "id": c.get("id"),
                "subject_name": c.get("subject_name"),
                "syllabus_id": c.get("syllabus_id"),
                "total_topics": len(c.get("topics", [])),
                "total_days": c.get("total_days", 0),
                "start_date": c.get("start_date"),
                "end_date": c.get("end_date"),
                "created_at": c.get("created_at")
            })
        
        return {
            "user_id": user_id,
            "count": len(summaries),
            "curricula": summaries
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Get curricula error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/today/{user_id}")
async def get_today_goals(user_id: str):
    """
    Get today's learning goals for a user.
    
    Returns the daily goals that should be completed today
    based on the user's active curriculum.
    """
    try:
        from app.services.curriculum_storage import get_curriculum_storage
        
        storage = get_curriculum_storage()
        curricula = storage.get_user_curricula(user_id)
        
        today = datetime.now().strftime("%Y-%m-%d")
        today_goals = []
        
        for curriculum in curricula:
            daily_goals = curriculum.get("daily_goals", [])
            
            for goal in daily_goals:
                if goal.get("date") == today:
                    # Get progress for each topic
                    progress = storage.get_curriculum_progress(curriculum.get("id", ""))
                    
                    topic_statuses = []
                    for topic_name in goal.get("topics", []):
                        # Find topic progress
                        status = "not_started"
                        if progress:
                            for tp in progress.topic_progress.values():
                                if tp.topic_name == topic_name:
                                    status = tp.status
                                    break
                        topic_statuses.append({
                            "name": topic_name,
                            "status": status
                        })
                    
                    today_goals.append({
                        "curriculum_id": curriculum.get("id"),
                        "subject_name": curriculum.get("subject_name"),
                        "day": goal.get("day"),
                        "topics": topic_statuses,
                        "activities": goal.get("activities", []),
                        "total_hours": goal.get("total_hours", 0),
                        "milestone": goal.get("milestone")
                    })
        
        return {
            "user_id": user_id,
            "date": today,
            "goals": today_goals,
            "has_goals": len(today_goals) > 0
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Get today error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/progress")
async def update_progress(request: UpdateProgressRequest):
    """
    Update progress on a curriculum topic.
    
    Call this when:
    - Student starts a topic (status: "in_progress")
    - Student completes a topic (status: "completed")
    - Student finishes a quiz (mastery score)
    """
    try:
        from app.services.curriculum_storage import get_curriculum_storage
        
        storage = get_curriculum_storage()
        
        # Update topic progress
        progress = storage.update_topic_progress(
            curriculum_id=request.curriculum_id,
            topic_id=request.topic_id,
            status=request.status,
            mastery=request.mastery,
            time_spent_minutes=request.time_spent_min
        )
        
        logger.info(
            f"[CURRICULUM-API] Progress update: {request.topic_id} -> {request.status}"
        )
        
        return {
            "success": True,
            "curriculum_id": request.curriculum_id,
            "topic_id": request.topic_id,
            "status": request.status,
            "mastery": progress.mastery,
            "time_spent_minutes": progress.time_spent_minutes
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Progress update error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/preview-topics")
async def preview_curriculum_topics(
    syllabus_id: str = Query(..., description="Syllabus ID"),
    subject_name: str = Query(..., description="Subject name")
):
    """
    Preview topics that would be in a curriculum.
    
    Use this to show users what topics will be covered
    before generating the full curriculum.
    """
    try:
        from app.services.syllabus_extractor import get_syllabus_extractor
        
        extractor = get_syllabus_extractor()
        
        # Get topics from syllabus
        # This searches the syllabus_content Qdrant collection
        results = extractor.search_syllabus_content(
            query="*",  # All content
            classroom_id=None,
            subject=subject_name,
            top_k=50
        )
        
        # Extract unique topics
        topics = set()
        for r in results:
            if r.get("chapter"):
                topics.add(r["chapter"])
        
        return {
            "syllabus_id": syllabus_id,
            "subject": subject_name,
            "topics": list(topics),
            "count": len(topics)
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Preview error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/health")
async def curriculum_health():
    """Check curriculum service health"""
    try:
        from app.agents import get_curriculum_agent
        
        agent = get_curriculum_agent()
        
        return {
            "status": "healthy",
            "service": "curriculum-agent",
            "agent_loaded": agent is not None
        }
        
    except Exception as e:
        return {
            "status": "degraded",
            "error": str(e)
        }

# ============================================================================
# Progress Dashboard Endpoints (Phase 4)
# ============================================================================

@router.get("/progress/{curriculum_id}")
async def get_curriculum_progress(curriculum_id: str):
    """
    Get detailed progress for a curriculum.
    
    Returns:
    - Overall completion percentage
    - Per-topic progress with mastery scores
    - Days behind schedule
    - Time spent statistics
    """
    try:
        from app.services.curriculum_storage import get_curriculum_storage
        
        storage = get_curriculum_storage()
        progress = storage.get_curriculum_progress(curriculum_id)
        
        if not progress:
            raise HTTPException(
                status_code=404,
                detail=f"Curriculum {curriculum_id} not found"
            )
        
        return {
            "success": True,
            "curriculum_id": curriculum_id,
            "progress": {
                "total_topics": progress.total_topics,
                "completed_topics": progress.completed_topics,
                "in_progress_topics": progress.in_progress_topics,
                "completion_percent": round(
                    progress.completed_topics / progress.total_topics * 100
                    if progress.total_topics > 0 else 0, 1
                ),
                "overall_mastery": round(progress.overall_mastery, 2),
                "current_day": progress.current_day,
                "days_behind": progress.days_behind,
                "on_track": progress.days_behind == 0,
                "total_time_spent_minutes": progress.total_time_spent_minutes,
                "last_active": progress.last_active,
                "topics": [
                    {
                        "topic_id": tp.topic_id,
                        "topic_name": tp.topic_name,
                        "status": tp.status,
                        "mastery": round(tp.mastery, 2),
                        "time_spent_minutes": tp.time_spent_minutes,
                        "quiz_attempts": tp.quiz_attempts,
                        "last_quiz_score": tp.last_quiz_score
                    }
                    for tp in progress.topic_progress.values()
                ]
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Get progress error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


class RescheduleRequest(BaseModel):
    """Request to reschedule a curriculum"""
    curriculum_id: str = Field(..., description="Curriculum ID")
    new_hours_per_day: Optional[float] = Field(
        default=None, ge=0.5, le=8.0,
        description="New daily study hours"
    )
    extend_days: Optional[int] = Field(
        default=None, ge=1, le=90,
        description="Days to extend deadline"
    )


@router.post("/reschedule")
async def reschedule_curriculum(request: RescheduleRequest):
    """
    Reschedule a curriculum when student falls behind.
    
    This will:
    1. Calculate remaining topics
    2. Create new daily goals for remaining content
    3. Update end date
    
    Use when:
    - Student is behind schedule (days_behind > 0)
    - Student wants to change study intensity
    - Exam date changed
    """
    try:
        from app.services.curriculum_storage import get_curriculum_storage
        
        storage = get_curriculum_storage()
        
        updated = storage.reschedule_curriculum(
            curriculum_id=request.curriculum_id,
            new_hours_per_day=request.new_hours_per_day,
            extend_days=request.extend_days
        )
        
        if not updated:
            raise HTTPException(
                status_code=404,
                detail=f"Curriculum {request.curriculum_id} not found"
            )
        
        return {
            "success": True,
            "rescheduled": True,
            "curriculum_id": request.curriculum_id,
            "new_end_date": updated.get("end_date"),
            "new_total_days": updated.get("total_days"),
            "daily_goals_count": len(updated.get("daily_goals", []))
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Reschedule error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{curriculum_id}")
async def get_curriculum_detail(curriculum_id: str):
    """
    Get full curriculum details by ID.
    
    Returns complete curriculum with topics, schedule, and progress.
    """
    try:
        from app.services.curriculum_storage import get_curriculum_storage
        
        storage = get_curriculum_storage()
        curriculum = storage.get_curriculum(curriculum_id)
        
        if not curriculum:
            raise HTTPException(
                status_code=404,
                detail=f"Curriculum {curriculum_id} not found"
            )
        
        # Include progress summary
        progress = storage.get_curriculum_progress(curriculum_id)
        
        return {
            "success": True,
            "curriculum": curriculum,
            "progress_summary": {
                "completed": progress.completed_topics if progress else 0,
                "total": progress.total_topics if progress else len(curriculum.get("topics", [])),
                "mastery": round(progress.overall_mastery, 2) if progress else 0.0,
                "days_behind": progress.days_behind if progress else 0
            } if progress else None
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Get curriculum error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/{curriculum_id}")
async def delete_curriculum(
    curriculum_id: str,
    user_id: str = Query(..., description="User ID for authorization")
):
    """Delete a curriculum by ID."""
    try:
        from app.services.curriculum_storage import get_curriculum_storage
        
        storage = get_curriculum_storage()
        
        # Verify ownership
        curriculum = storage.get_curriculum(curriculum_id)
        if not curriculum:
            raise HTTPException(status_code=404, detail="Curriculum not found")
        
        if curriculum.get("user_id") != user_id:
            raise HTTPException(status_code=403, detail="Not authorized")
        
        storage.delete_curriculum(curriculum_id, user_id)
        
        return {"success": True, "deleted": curriculum_id}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Delete error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


class ReconfigureRequest(BaseModel):
    """Request to reconfigure curriculum schedule"""
    user_id: str = Field(..., description="User ID")
    hours_per_day: float = Field(default=2.0, ge=0.5, le=8, description="Study hours per day")
    deadline_days: int = Field(default=14, ge=7, le=90, description="Target days to complete")


@router.post("/{curriculum_id}/reconfigure")
async def reconfigure_curriculum(
    curriculum_id: str,
    request: ReconfigureRequest
):
    """
    Reconfigure an existing curriculum's schedule.
    
    Keeps the same topics but regenerates the schedule with new parameters:
    - hours_per_day: Daily study time
    - deadline_days: Target completion time
    
    This allows students to adjust their study plan without re-uploading the syllabus.
    """
    try:
        from app.services.curriculum_storage import get_curriculum_storage
        
        storage = get_curriculum_storage()
        
        # Get existing curriculum
        curriculum = storage.get_curriculum(curriculum_id)
        if not curriculum:
            raise HTTPException(status_code=404, detail="Curriculum not found")
        
        # Verify ownership
        if curriculum.get("user_id") != request.user_id:
            raise HTTPException(status_code=403, detail="Not authorized")
        
        logger.info(f"[CURRICULUM-API] Reconfiguring {curriculum_id}: hours={request.hours_per_day}, days={request.deadline_days}")
        
        # Get existing topics
        topics = curriculum.get("topics", [])
        if not topics:
            raise HTTPException(status_code=400, detail="Curriculum has no topics to reschedule")
        
        # Regenerate schedule with new parameters
        from datetime import datetime, timedelta
        
        start_date = datetime.now()
        end_date = start_date + timedelta(days=request.deadline_days)
        
        # Calculate topic distribution
        total_hours = request.hours_per_day * request.deadline_days
        hours_per_topic = total_hours / len(topics) if topics else 1
        
        # Redistribute topics across the schedule
        current_date = start_date
        schedule = {}
        topics_per_day = max(1, int(request.hours_per_day / hours_per_topic)) if hours_per_topic > 0 else 1
        
        for i, topic in enumerate(topics):
            date_str = current_date.strftime("%Y-%m-%d")
            
            if date_str not in schedule:
                schedule[date_str] = []
            
            schedule[date_str].append({
                "topic_id": topic.get("id", f"topic_{i}"),
                "topic_name": topic.get("name", f"Topic {i+1}"),
                "status": "scheduled",
                "confidence_score": topic.get("confidence_score", 0)
            })
            
            # Move to next day after topics_per_day topics
            if len(schedule[date_str]) >= topics_per_day:
                current_date += timedelta(days=1)
                # Skip weekends if configured
                while current_date.weekday() >= 5:  # Sat=5, Sun=6
                    current_date += timedelta(days=1)
        
        # Update curriculum with new schedule and parameters
        curriculum["schedule"] = schedule
        curriculum["hours_per_day"] = request.hours_per_day
        curriculum["deadline_days"] = request.deadline_days
        curriculum["start_date"] = start_date.strftime("%Y-%m-%d")
        curriculum["end_date"] = end_date.strftime("%Y-%m-%d")
        curriculum["updated_at"] = datetime.now().isoformat()
        
        # Save updated curriculum
        storage.save_curriculum(curriculum)
        
        logger.info(f"[CURRICULUM-API] Reconfigured {curriculum_id}: {len(topics)} topics over {request.deadline_days} days")
        
        return {
            "success": True,
            "curriculum": curriculum,
            "message": f"Schedule updated for {len(topics)} topics over {request.deadline_days} days"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Reconfigure error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/storage/stats")
async def get_storage_stats():
    """Get storage statistics for debugging."""
    try:
        from app.services.curriculum_storage import get_curriculum_storage
        
        storage = get_curriculum_storage()
        stats = storage.get_storage_stats()
        
        return {
            "success": True,
            "stats": stats
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Stats error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# Assessment Endpoints (Phase 3)
# ============================================================================

class GenerateAssessmentRequest(BaseModel):
    """Request to generate diagnostic assessment"""
    curriculum_id: str = Field(default="", description="Curriculum ID (optional)")
    user_id: str = Field(..., description="Student ID")
    topics: List[Dict] = Field(..., description="List of topics with id, name, description")
    questions_per_topic: int = Field(default=3, ge=1, le=10, description="Questions per topic")
    difficulty: str = Field(default="mixed", description="easy, medium, hard, or mixed")


class EvaluateAssessmentRequest(BaseModel):
    """Request to evaluate assessment responses"""
    quiz_id: str = Field(..., description="Quiz ID from generate_assessment")
    curriculum_id: str = Field(default="", description="Associated curriculum ID")
    user_id: str = Field(..., description="Student ID")
    responses: Dict[str, str] = Field(..., description="Map of question_id -> student answer")
    time_taken_seconds: int = Field(default=0, description="Total time taken")


@router.post("/assessment/generate")
async def generate_diagnostic_assessment(request: GenerateAssessmentRequest):
    """
    Generate a diagnostic assessment quiz for curriculum topics.
    
    This creates a quiz to test the student's existing knowledge
    before they start the curriculum. Results can be used to:
    - Skip topics they already know
    - Adjust time estimates
    - Prioritize weak areas
    
    Example:
    ```json
    {
        "user_id": "student123",
        "topics": [
            {"id": "t1", "name": "Algebra", "description": "Linear equations..."},
            {"id": "t2", "name": "Calculus", "description": "Derivatives..."}
        ],
        "questions_per_topic": 3
    }
    ```
    """
    try:
        from app.services.assessment_service import get_assessment_service
        
        assessment_service = get_assessment_service()
        
        quiz = await assessment_service.generate_diagnostic_quiz(
            curriculum_id=request.curriculum_id or f"temp_{request.user_id}",
            user_id=request.user_id,
            topics=request.topics,
            questions_per_topic=request.questions_per_topic,
            difficulty=request.difficulty
        )
        
        return {
            "success": True,
            "quiz": quiz.to_dict()
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Assessment generation error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/assessment/evaluate")
async def evaluate_assessment(request: EvaluateAssessmentRequest):
    """
    Evaluate student's diagnostic assessment responses.
    
    Returns mastery scores per topic that can be used to:
    - Generate a personalized curriculum
    - Adjust topic time estimates
    - Identify weak areas
    
    Example:
    ```json
    {
        "quiz_id": "quiz_abc123",
        "user_id": "student456",
        "responses": {
            "q_12345678": "A",
            "q_87654321": "C"
        }
    }
    ```
    """
    try:
        from app.services.assessment_service import get_assessment_service, DiagnosticQuiz, DiagnosticQuestion
        
        assessment_service = get_assessment_service()
        
        # For now, we need to reconstruct the quiz from the stored questions
        # In a production system, this would be fetched from database
        # For Phase 3, we'll use a simple approach
        
        # This is a placeholder - in production, fetch quiz from DB
        logger.info(
            f"[CURRICULUM-API] Evaluating {len(request.responses)} responses "
            f"for quiz {request.quiz_id}"
        )
        
        # Calculate simple mastery based on responses
        # In production, this would use the full quiz structure
        total_questions = len(request.responses)
        
        return {
            "success": True,
            "quiz_id": request.quiz_id,
            "user_id": request.user_id,
            "total_questions": total_questions,
            "responses_received": len(request.responses),
            "message": "Evaluation complete. Use results with curriculum generation.",
            "note": "Full evaluation requires quiz storage (Phase 4)"
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Evaluation error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/generate-with-assessment")
async def generate_curriculum_with_assessment(request: GenerateCurriculumRequest):
    """
    Generate curriculum with integrated diagnostic assessment.
    
    This is a combined workflow that:
    1. Generates a quick diagnostic quiz
    2. Evaluates based on assumed difficulty
    3. Creates personalized curriculum with adjusted hours
    
    For a full diagnostic flow, use:
    1. POST /assessment/generate
    2. (Student takes quiz)
    3. POST /assessment/evaluate
    4. POST /generate with mastery scores
    """
    try:
        from app.agents import get_curriculum_agent
        from app.services.assessment_service import get_assessment_service
        
        agent = get_curriculum_agent()
        assessment = get_assessment_service()
        
        topics = request.topics or []
        
        # Quick assessment to get baseline mastery
        topic_list = [
            {"id": t.get("id", t.get("name", "")), "name": t.get("name", ""), "description": t.get("description", "")}
            for t in topics
        ]
        
        mastery_scores = await assessment.quick_assessment(
            topics=topic_list,
            assumed_level="beginner"
        )
        
        result = await agent.generate({
            "syllabus_id": request.syllabus_id,
            "user_id": request.user_id,
            "classroom_id": request.classroom_id,
            "subject_name": request.subject_name,
            "raw_topics": topics,
            "hours_per_day": request.hours_per_day,
            "deadline_days": request.deadline_days,
            "start_date": request.start_date or datetime.now().strftime("%Y-%m-%d"),
            "student_knowledge": mastery_scores  # Pre-supply mastery
        })
        
        if not result.get("success"):
            raise HTTPException(
                status_code=400,
                detail=result.get("error", "Failed to generate curriculum")
            )
        
        curriculum = result.get("curriculum", {})
        total_topics = len(curriculum.get("topics", []))
        
        return {
            "success": True,
            "assessment_used": True,
            "mastery_scores": mastery_scores,
            "curriculum": {
                **curriculum,
                "total_topics": total_topics,
                "progress_percent": 0.0
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Generate with assessment error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# Spaced Repetition Endpoints (Phase 6)
# ============================================================================

class RecordReviewRequest(BaseModel):
    """Request to record a topic review"""
    user_id: str = Field(..., description="Student ID")
    topic_id: str = Field(..., description="Topic ID")
    topic_name: str = Field(..., description="Topic name")
    quality: int = Field(..., ge=0, le=5, description="Quality of recall (0-5)")


class LearningStyleRequest(BaseModel):
    """Request to update learning style"""
    user_id: str = Field(..., description="Student ID")
    primary_style: str = Field(..., description="visual, auditory, reading, kinesthetic")
    secondary_style: Optional[str] = Field(default=None, description="Optional secondary style")


class StudyPreferencesRequest(BaseModel):
    """Request to update study preferences"""
    user_id: str = Field(..., description="Student ID")
    session_minutes: Optional[int] = Field(default=None, ge=10, le=120)
    best_time: Optional[str] = Field(default=None, description="morning, afternoon, evening, night")
    topics_per_session: Optional[int] = Field(default=None, ge=1, le=10)


@router.post("/review/record")
async def record_review(request: RecordReviewRequest):
    """
    Record a topic review for spaced repetition.
    
    Quality scale (SM-2):
    - 0: Complete blackout
    - 1: Incorrect but recognized
    - 2: Correct with difficulty
    - 3: Correct with hesitation
    - 4: Correct after thinking
    - 5: Perfect instant recall
    
    Returns next review date and updated mastery.
    """
    try:
        from app.services.spaced_repetition import get_spaced_repetition_service
        
        service = get_spaced_repetition_service()
        item = service.record_review(
            user_id=request.user_id,
            topic_id=request.topic_id,
            topic_name=request.topic_name,
            quality=request.quality
        )
        
        return {
            "success": True,
            "topic_id": item.topic_id,
            "next_review": item.next_review,
            "interval_days": item.interval,
            "mastery": round(item.mastery * 100),
            "easiness_factor": round(item.easiness_factor, 2),
            "repetitions": item.repetitions
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Record review error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/review/due/{user_id}")
async def get_due_reviews(
    user_id: str,
    limit: int = Query(default=10, ge=1, le=50)
):
    """
    Get topics due for review today.
    
    Returns topics sorted by urgency (most overdue first).
    """
    try:
        from app.services.spaced_repetition import get_spaced_repetition_service
        
        service = get_spaced_repetition_service()
        due_items = service.get_due_reviews(user_id, limit=limit)
        
        return {
            "success": True,
            "user_id": user_id,
            "count": len(due_items),
            "reviews": [
                {
                    "topic_id": item.topic_id,
                    "topic_name": item.topic_name,
                    "next_review": item.next_review,
                    "last_review": item.last_review,
                    "mastery": round(item.mastery * 100),
                    "interval_days": item.interval
                }
                for item in due_items
            ]
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Get due reviews error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/study-session/{user_id}")
async def get_optimal_study_session(
    user_id: str,
    minutes: int = Query(default=30, ge=10, le=180)
):
    """
    Generate an optimal study session based on spaced repetition.
    
    Includes:
    - Topics due for review
    - Time allocation per topic
    - Resource suggestions based on learning style
    """
    try:
        from app.services.spaced_repetition import get_spaced_repetition_service
        
        service = get_spaced_repetition_service()
        session = service.get_optimal_study_session(
            user_id=user_id,
            available_minutes=minutes
        )
        
        return {
            "success": True,
            **session
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Study session error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/learning-style/quiz")
async def get_learning_style_quiz():
    """
    Get a VARK learning style quiz.
    
    Returns questions to determine student's preferred learning style:
    - Visual: Diagrams, videos, charts
    - Auditory: Lectures, podcasts, discussions
    - Reading: Text, notes, articles
    - Kinesthetic: Practice, experiments, hands-on
    """
    try:
        from app.services.spaced_repetition import get_spaced_repetition_service
        
        service = get_spaced_repetition_service()
        quiz = service.get_learning_style_quiz()
        
        return {
            "success": True,
            "quiz": quiz
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Learning style quiz error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


class LearningStyleQuizSubmission(BaseModel):
    """Quiz submission with answers"""
    user_id: str = Field(..., description="Student ID")
    responses: Dict[str, str] = Field(..., description="Map of question_id -> answer style")


@router.post("/learning-style/analyze")
async def analyze_learning_style(submission: LearningStyleQuizSubmission):
    """
    Analyze quiz responses and determine learning style.
    
    Updates user's learning profile with results.
    """
    try:
        from app.services.spaced_repetition import get_spaced_repetition_service
        
        service = get_spaced_repetition_service()
        primary, secondary = service.analyze_learning_style_quiz(submission.responses)
        
        # Update profile
        profile = service.update_learning_style(
            user_id=submission.user_id,
            primary=primary.value,
            secondary=secondary.value if secondary else None
        )
        
        return {
            "success": True,
            "user_id": submission.user_id,
            "primary_style": primary.value,
            "secondary_style": secondary.value if secondary else None,
            "description": _get_style_description(primary),
            "study_tips": _get_style_tips(primary)
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Analyze learning style error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/learning-style/update")
async def update_learning_style(request: LearningStyleRequest):
    """Manually update learning style preference."""
    try:
        from app.services.spaced_repetition import get_spaced_repetition_service
        
        service = get_spaced_repetition_service()
        profile = service.update_learning_style(
            user_id=request.user_id,
            primary=request.primary_style,
            secondary=request.secondary_style
        )
        
        return {
            "success": True,
            "user_id": request.user_id,
            "primary_style": profile.primary_style.value,
            "secondary_style": profile.secondary_style.value if profile.secondary_style else None
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Update learning style error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/study-preferences")
async def update_study_preferences(request: StudyPreferencesRequest):
    """Update study preferences like session length and best study time."""
    try:
        from app.services.spaced_repetition import get_spaced_repetition_service
        
        service = get_spaced_repetition_service()
        profile = service.update_study_preferences(
            user_id=request.user_id,
            session_minutes=request.session_minutes,
            best_time=request.best_time,
            topics_per_session=request.topics_per_session
        )
        
        return {
            "success": True,
            "user_id": request.user_id,
            "session_minutes": profile.preferred_session_minutes,
            "best_time": profile.best_study_time,
            "topics_per_session": profile.topics_per_session
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Update preferences error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/profile/{user_id}")
async def get_learning_profile(user_id: str):
    """Get user's complete learning profile."""
    try:
        from app.services.spaced_repetition import get_spaced_repetition_service
        
        service = get_spaced_repetition_service()
        profile = service.get_or_create_profile(user_id)
        
        return {
            "success": True,
            "profile": {
                "user_id": profile.user_id,
                "primary_style": profile.primary_style.value,
                "secondary_style": profile.secondary_style.value if profile.secondary_style else None,
                "session_minutes": profile.preferred_session_minutes,
                "best_time": profile.best_study_time,
                "topics_per_session": profile.topics_per_session,
                "retention_strength": profile.retention_strength,
                "total_review_items": len(profile.review_items)
            }
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Get profile error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# Helper Functions
# ============================================================================

def _get_style_description(style) -> str:
    """Get description for a learning style"""
    descriptions = {
        "visual": "You learn best through visual aids like diagrams, charts, videos, and written notes with highlights.",
        "auditory": "You learn best through listening - lectures, podcasts, discussions, and verbal explanations.",
        "reading": "You learn best through reading and writing - textbooks, articles, notes, and written summaries.",
        "kinesthetic": "You learn best through hands-on experience - practice problems, experiments, and physical activities."
    }
    return descriptions.get(style.value, "")


def _get_style_tips(style) -> List[str]:
    """Get study tips for a learning style"""
    tips = {
        "visual": [
            "Use color-coded notes and highlighters",
            "Create mind maps and diagrams",
            "Watch educational videos",
            "Use flashcards with images"
        ],
        "auditory": [
            "Listen to lectures and podcasts",
            "Explain concepts out loud",
            "Join study groups for discussion",
            "Record yourself reading notes"
        ],
        "reading": [
            "Take detailed written notes",
            "Read textbooks and articles",
            "Write summaries in your own words",
            "Use lists and bullet points"
        ],
        "kinesthetic": [
            "Practice problems frequently",
            "Use hands-on experiments",
            "Take breaks to move around",
            "Associate concepts with actions"
        ]
    }
    return tips.get(style.value, [])


# ============================================================================
# Exam Prep Endpoints (Phase 7)
# ============================================================================

class CreateExamPrepRequest(BaseModel):
    """Request to create exam prep plan"""
    exam_name: str = Field(..., description="Name of the exam")
    exam_date: str = Field(..., description="Exam date (YYYY-MM-DD)")
    curriculum_id: str = Field(..., description="Associated curriculum")
    user_id: str = Field(..., description="Student ID")
    hours_per_day: float = Field(default=3.0, ge=1.0, le=8.0)
    include_resources: bool = Field(default=True)


@router.post("/exam-prep/create")
async def create_exam_prep(request: CreateExamPrepRequest):
    """
    Create an intensive exam preparation plan.
    
    Features:
    - Prioritizes weak topics (low mastery)
    - Inserts review days based on spaced repetition
    - Fetches resource recommendations
    - Generates practice test schedule
    
    Use this when a student has an upcoming exam and needs
    an intensified study schedule.
    """
    try:
        from app.services.exam_prep import get_exam_prep_service
        
        service = get_exam_prep_service()
        plan = await service.create_exam_prep_plan(
            exam_name=request.exam_name,
            exam_date=request.exam_date,
            curriculum_id=request.curriculum_id,
            user_id=request.user_id,
            hours_per_day=request.hours_per_day,
            include_resources=request.include_resources
        )
        
        return {
            "success": True,
            "exam_prep": plan.to_dict()
        }
        
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Exam prep error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/exam-prep/{exam_id}")
async def get_exam_prep(exam_id: str):
    """Get an existing exam prep plan."""
    try:
        from app.services.exam_prep import get_exam_prep_service
        
        service = get_exam_prep_service()
        plan = service.get_prep_plan(exam_id)
        
        if not plan:
            raise HTTPException(status_code=404, detail="Exam prep plan not found")
        
        return {
            "success": True,
            "exam_prep": plan.to_dict()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Get exam prep error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/exam-prep/curriculum/{curriculum_id}")
async def get_curriculum_exams(curriculum_id: str):
    """Get all exams for a curriculum."""
    try:
        from app.services.exam_prep import get_exam_prep_service
        
        service = get_exam_prep_service()
        exams = service.get_user_exams(curriculum_id)
        
        return {
            "success": True,
            "curriculum_id": curriculum_id,
            "count": len(exams),
            "exams": [
                {
                    "exam_id": e.exam_id,
                    "name": e.name,
                    "subject": e.subject,
                    "date": e.date,
                    "topics_count": len(e.topics)
                }
                for e in exams
            ]
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Get curriculum exams error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# Resource Suggestion Endpoints (Phase 7)
# ============================================================================

@router.get("/resources/{topic}")
async def get_topic_resources(
    topic: str,
    subject: str = Query(default="", description="Subject context"),
    learning_style: str = Query(default="", description="Preferred learning style"),
    limit: int = Query(default=5, ge=1, le=20)
):
    """
    Get learning resources for a specific topic.
    
    Uses the Research Agent to find:
    - Educational articles and guides
    - YouTube videos
    - PDFs and documents
    
    Results are filtered by learning style if provided.
    """
    try:
        from app.agents import get_research_agent
        
        agent = get_research_agent()
        
        # Build search query
        query = topic
        if subject:
            query = f"{topic} {subject}"
        
        # Add learning style keywords
        style_keywords = {
            "visual": "video diagram infographic",
            "auditory": "audio podcast lecture",
            "reading": "article guide textbook",
            "kinesthetic": "practice exercise hands-on"
        }
        if learning_style in style_keywords:
            query += f" {style_keywords[learning_style]}"
        
        result = await agent.execute({
            "query": query + " tutorial educational",
            "user_id": "system",
            "search_web": True,
            "search_youtube": True,
            "search_pdfs": True,
            "max_results": limit
        })
        
        resources = []
        
        # Process web results
        for r in result.get("web_results", [])[:limit]:
            resources.append({
                "type": "article",
                "title": r.get("title", ""),
                "url": r.get("url", ""),
                "description": r.get("snippet", ""),
                "source": "web"
            })
        
        # Process YouTube results
        for r in result.get("youtube_results", [])[:limit]:
            resources.append({
                "type": "video",
                "title": r.get("title", ""),
                "url": r.get("url", ""),
                "description": r.get("description", ""),
                "source": "youtube"
            })
        
        # Process PDF results
        for r in result.get("pdf_results", [])[:limit]:
            resources.append({
                "type": "pdf",
                "title": r.get("title", ""),
                "url": r.get("url", ""),
                "description": r.get("snippet", ""),
                "source": "web"
            })
        
        return {
            "success": True,
            "topic": topic,
            "learning_style": learning_style or "any",
            "count": len(resources),
            "resources": resources[:limit]
        }
        
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Resource search error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# Syllabus Upload Endpoints (Phase 7)
# ============================================================================

from fastapi import UploadFile, File, Form


@router.post("/syllabus/upload")
async def upload_syllabus_and_generate(
    file: UploadFile = File(...),
    user_id: str = Form(...),
    subject_name: str = Form(...),
    hours_per_day: float = Form(default=2.0),
    deadline_days: int = Form(default=14),
    curriculum_id: str = Form(default=None)  # If provided, reconfigure existing curriculum
):
    """
    Upload a syllabus PDF and generate curriculum automatically.
    
    Complete workflow:
    1. Save uploaded PDF
    2. Extract topics using SyllabusExtractor
    3. Generate personalized curriculum
    4. Return curriculum with learning path
    
    If curriculum_id is provided, the existing curriculum will be replaced (reconfiguration mode).
    
    Accepts PDF files up to 10MB.
    """
    import os
    import tempfile
    import uuid
    
    # Validate file type
    if not file.filename.endswith('.pdf'):
        raise HTTPException(status_code=400, detail="Only PDF files are supported")
    
    # Check file size (10MB limit)
    file_content = await file.read()
    if len(file_content) > 10 * 1024 * 1024:
        raise HTTPException(status_code=400, detail="File size exceeds 10MB limit")
    
    try:
        # If reconfiguring, delete the old curriculum first
        is_reconfiguring = bool(curriculum_id)
        if is_reconfiguring:
            logger.info(f"[CURRICULUM-API] Reconfiguring curriculum {curriculum_id}")
            from app.services.curriculum_storage import get_curriculum_storage
            storage = get_curriculum_storage()
            storage.delete_curriculum(curriculum_id, user_id)
        
        # Save to temp file
        syllabus_id = f"syllabus_{uuid.uuid4().hex[:12]}"
        temp_dir = tempfile.gettempdir()
        pdf_path = os.path.join(temp_dir, f"{syllabus_id}.pdf")
        
        with open(pdf_path, 'wb') as f:
            f.write(file_content)
        
        logger.info(f"[CURRICULUM-API] Saved syllabus {syllabus_id} to {pdf_path}")
        
        # Extract topics using syllabus extractor
        from app.services.syllabus_extractor import get_syllabus_extractor
        
        extractor = get_syllabus_extractor()
        extraction = await extractor.process_syllabus(
            syllabus_id=syllabus_id,
            pdf_path=pdf_path,
            classroom_id=f"curriculum_{user_id}",
            subject_name=subject_name,
            title=file.filename
        )
        
        if not extraction.success:
            raise HTTPException(
                status_code=400, 
                detail=f"Failed to extract syllabus: {extraction.error}"
            )
        
        logger.info(
            f"[CURRICULUM-API] Extracted {extraction.topics_extracted} topics "
            f"from syllabus {syllabus_id}"
        )
        
        # Get topics using robust multi-method extractor
        from app.services.topic_extractor import get_topic_extractor
        
        topic_extractor = get_topic_extractor()
        extracted_topics = topic_extractor.extract_topics(
            pdf_path=pdf_path,
            subject_name=subject_name,
            prefer_ai=True
        )
        
        # Convert to curriculum format
        topic_list = []
        for i, et in enumerate(extracted_topics):
            topic_list.append({
                "id": f"topic_{i}",
                "name": et.name,
                "description": et.description or f"Topic covering {et.name}",
                "difficulty": et.difficulty,
                "estimated_hours": et.estimated_hours,
                "subtopics": et.subtopics
            })
        
        logger.info(f"[CURRICULUM-API] Using {len(topic_list)} topics from topic_extractor")
        
        # Generate curriculum
        from app.agents import get_curriculum_agent
        
        agent = get_curriculum_agent()
        result = await agent.generate({
            "syllabus_id": syllabus_id,
            "user_id": user_id,
            "subject_name": subject_name,
            "raw_topics": topic_list,
            "hours_per_day": hours_per_day,
            "deadline_days": deadline_days,
            "start_date": datetime.now().strftime("%Y-%m-%d")
        })
        
        # Clean up temp file
        try:
            os.remove(pdf_path)
        except:
            pass
        
        if not result.get("success"):
            raise HTTPException(
                status_code=400,
                detail=result.get("error", "Failed to generate curriculum")
            )
        
        curriculum = result.get("curriculum", {})
        
        # Store curriculum
        from app.services.curriculum_storage import get_curriculum_storage
        storage = get_curriculum_storage()
        storage.save_curriculum(curriculum)
        
        return {
            "success": True,
            "syllabus_id": syllabus_id,
            "topics_extracted": len(topic_list),
            "curriculum": curriculum
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Syllabus upload error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/syllabus/extract-topics")
async def extract_topics_only(
    file: UploadFile = File(...),
    subject_name: str = Form(...)
):
    """
    Extract topics from syllabus without generating curriculum.
    
    Use this to preview what topics will be extracted before
    committing to full curriculum generation.
    """
    import os
    import tempfile
    import uuid
    
    if not file.filename.endswith('.pdf'):
        raise HTTPException(status_code=400, detail="Only PDF files are supported")
    
    file_content = await file.read()
    if len(file_content) > 10 * 1024 * 1024:
        raise HTTPException(status_code=400, detail="File size exceeds 10MB limit")
    
    try:
        syllabus_id = f"preview_{uuid.uuid4().hex[:12]}"
        temp_dir = tempfile.gettempdir()
        pdf_path = os.path.join(temp_dir, f"{syllabus_id}.pdf")
        
        with open(pdf_path, 'wb') as f:
            f.write(file_content)
        
        from app.services.syllabus_extractor import get_syllabus_extractor
        
        extractor = get_syllabus_extractor()
        extraction = await extractor.process_syllabus(
            syllabus_id=syllabus_id,
            pdf_path=pdf_path,
            classroom_id="preview",
            subject_name=subject_name,
            title=file.filename
        )
        
        if not extraction.success:
            # Clean up on failure
            try:
                os.remove(pdf_path)
            except:
                pass
            raise HTTPException(
                status_code=400,
                detail=f"Extraction failed: {extraction.error}"
            )
        
        # Get topics using robust multi-method extractor
        from app.services.topic_extractor import get_topic_extractor
        
        topic_extractor = get_topic_extractor()
        extracted_topics = topic_extractor.extract_topics(
            pdf_path=pdf_path,
            subject_name=subject_name,
            prefer_ai=True
        )
        
        # Clean up PDF after extraction
        try:
            os.remove(pdf_path)
        except:
            pass
        
        # Format topics for response
        topic_names = [et.name for et in extracted_topics]
        topics_detailed = [
            {
                "name": et.name,
                "description": et.description,
                "difficulty": et.difficulty,
                "estimated_hours": et.estimated_hours,
                "subtopics": et.subtopics,
                "source": et.source
            }
            for et in extracted_topics
        ]
        
        return {
            "success": True,
            "filename": file.filename,
            "topics_count": len(topic_names),
            "topics": topic_names,
            "topics_detailed": topics_detailed,
            "preview_id": syllabus_id,
            "extraction_source": extracted_topics[0].source if extracted_topics else "none"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[CURRICULUM-API] Extract topics error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

